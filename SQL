-- DiU Forum Supabase Migrations & Instructions
-- File: SQL
-- Purpose: full SQL to create required tables, indexes, triggers and RLS policy examples
-- Instructions (short):
-- 1) In the Supabase Dashboard: open SQL Editor and paste this file's SQL and run as a single script.
--    Or, if you use the `supabase` CLI, add this SQL as a migration and run `supabase db push` / `supabase migration run` per your workflow.
-- 2) After running, enable Realtime (Replication) for the tables `posts`, `comments`, `post_likes` in the Supabase UI: Database -> Realtime settings.
-- 3) In Supabase Auth settings, add your app redirect URIs (e.g., `https://yourdomain.com/*` and `http://localhost:5173` or your local static server origin) so OAuth redirect flows work.
-- 4) Test with a DIU Google account (addresses ending in `@diu.edu.bd`). The policy examples below enforce DIU domain â€” adjust if your JWT claim path differs.
-- NOTE on RLS expressions: Supabase exposes JWT claims in policies differently depending on version. The script below uses the common `auth.jwt()` expression; if your project fails to evaluate `auth.jwt()`, replace uses with `current_setting('jwt.claims.email', true)` or consult your Supabase project docs.

-- =====================================================
-- SCHEMA: profiles (basic user profile), posts, comments, post_likes
-- =====================================================

-- Enable uuid-ossp extension (if not already available)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Profiles table: optional basic profile store (keeps display name, avatar, metadata)
CREATE TABLE IF NOT EXISTS profiles (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  auth_id uuid UNIQUE, -- store auth uid if desired (supabase auth uid)
  email text UNIQUE,
  full_name text,
  avatar_url text,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Posts table: forum posts / blog posts
CREATE TABLE IF NOT EXISTS posts (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  author_id uuid REFERENCES profiles(id) ON DELETE SET NULL,
  title text NOT NULL,
  slug text UNIQUE,
  body text,
  body_html text,
  metadata jsonb DEFAULT '{}'::jsonb,
  like_count integer NOT NULL DEFAULT 0,
  comment_count integer NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Jobs and education opportunities (basic structure)
CREATE TABLE IF NOT EXISTS jobs (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  author_id uuid REFERENCES profiles(id) ON DELETE SET NULL,
  title text NOT NULL,
  company text,
  location text,
  description text,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS education_opportunities (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  author_id uuid REFERENCES profiles(id) ON DELETE SET NULL,
  title text NOT NULL,
  provider text,
  description text,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Comments table: comments on posts (supports replies via `parent_id`)
CREATE TABLE IF NOT EXISTS comments (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  post_id uuid REFERENCES posts(id) ON DELETE CASCADE,
  parent_id uuid REFERENCES comments(id) ON DELETE CASCADE,
  author_id uuid REFERENCES profiles(id) ON DELETE SET NULL,
  content text NOT NULL,
  reply_count integer NOT NULL DEFAULT 0,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Post likes table: one row per (post_id, user_id)
CREATE TABLE IF NOT EXISTS post_likes (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  post_id uuid REFERENCES posts(id) ON DELETE CASCADE,
  user_id uuid REFERENCES profiles(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT unique_post_user_like UNIQUE (post_id, user_id)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id);
CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments(parent_id);
CREATE INDEX IF NOT EXISTS idx_post_likes_post_id ON post_likes(post_id);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON profiles(email);

-- =====================================================
-- TRIGGERS: maintain counters (like_count and comment_count)
-- =====================================================
-- Function to increment comment_count on posts
CREATE OR REPLACE FUNCTION increment_comment_count()
RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    UPDATE posts SET comment_count = comment_count + 1, updated_at = now() WHERE id = NEW.post_id;
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    UPDATE posts SET comment_count = GREATEST(comment_count - 1, 0), updated_at = now() WHERE id = OLD.post_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS comments_count_trigger ON comments;
CREATE TRIGGER comments_count_trigger
AFTER INSERT OR DELETE ON comments
FOR EACH ROW EXECUTE FUNCTION increment_comment_count();

-- Function to increment/decrement reply_count on parent comments
CREATE OR REPLACE FUNCTION increment_reply_count()
RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF NEW.parent_id IS NOT NULL THEN
      UPDATE comments SET reply_count = reply_count + 1 WHERE id = NEW.parent_id;
    END IF;
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    IF OLD.parent_id IS NOT NULL THEN
      UPDATE comments SET reply_count = GREATEST(reply_count - 1, 0) WHERE id = OLD.parent_id;
    END IF;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS replies_count_trigger ON comments;
CREATE TRIGGER replies_count_trigger
AFTER INSERT OR DELETE ON comments
FOR EACH ROW EXECUTE FUNCTION increment_reply_count();

-- Function to increment/decrement like_count on posts
CREATE OR REPLACE FUNCTION toggle_like_count()
RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    UPDATE posts SET like_count = like_count + 1, updated_at = now() WHERE id = NEW.post_id;
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    UPDATE posts SET like_count = GREATEST(like_count - 1, 0), updated_at = now() WHERE id = OLD.post_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS likes_count_trigger ON post_likes;
CREATE TRIGGER likes_count_trigger
AFTER INSERT OR DELETE ON post_likes
FOR EACH ROW EXECUTE FUNCTION toggle_like_count();

-- =====================================================
-- RLS (Row Level Security) EXAMPLES
-- =====================================================
-- NOTE: Enabling RLS without providing working policies will lock access; read the notes and either
--  (A) apply the policies below and verify they match your project's JWT claim shape, or
--  (B) keep RLS disabled until you are ready to craft policies.

-- Example policy style using auth.jwt() to inspect email claim. If your Supabase returns JWT claims differently,
-- replace `(auth.jwt() ->> 'email')` with the appropriate method (e.g. `current_setting('jwt.claims.email', true)`)

-- Enable RLS on tables we want protected
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE post_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE education_opportunities ENABLE ROW LEVEL SECURITY;

-- Allow authenticated DIU users to SELECT posts/comments/jobs/education_opportunities
-- Using auth.jwt() ->> 'email' pattern; adjust if your environment differs.

-- Posts: allow SELECT for authenticated DIU email addresses
CREATE POLICY "Allow DIU read posts" ON posts
  FOR SELECT
  USING (
    (auth.role() = 'authenticated')
    AND (
      (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd'
      OR (current_setting('jwt.claims.email', true) LIKE '%@diu.edu.bd')
    )
  );

-- Comments: allow users to insert comments if authenticated DIU user
CREATE POLICY "Insert comments for DIU users" ON comments
  FOR INSERT
  WITH CHECK (
    (auth.role() = 'authenticated')
    AND (
      (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd'
      OR (current_setting('jwt.claims.email', true) LIKE '%@diu.edu.bd')
    )
  );

-- Comments: allow authenticated DIU users to read comments
CREATE POLICY "Select comments for DIU users" ON comments
  FOR SELECT
  USING (
    (auth.role() = 'authenticated')
    AND (
      (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd'
      OR (current_setting('jwt.claims.email', true) LIKE '%@diu.edu.bd')
    )
  );

-- Post_likes: allow insert/delete for DIU users (create a like), ensure uniqueness by constraint
CREATE POLICY "Insert likes for DIU users" ON post_likes
  FOR INSERT
  WITH CHECK (
    (auth.role() = 'authenticated')
    AND (
      (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd'
      OR (current_setting('jwt.claims.email', true) LIKE '%@diu.edu.bd')
    )
  );

CREATE POLICY "Delete own like" ON post_likes
  FOR DELETE
  USING (
    (auth.role() = 'authenticated')
    AND (user_id = auth.uid())
  );

-- Profiles: allow each user to insert their profile and read own profile; admins can be granted separately
CREATE POLICY "Insert own profile" ON profiles
  FOR INSERT
  WITH CHECK (
    auth.role() = 'authenticated'
  );

CREATE POLICY "Select own profile" ON profiles
  FOR SELECT
  USING (
    (auth.role() = 'authenticated')
    AND (auth.uid() = auth_id OR (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd')
  );

-- Posts: allow authenticated DIU users to insert posts; allow owners to update/delete their posts
CREATE POLICY "Insert posts for DIU users" ON posts
  FOR INSERT
  WITH CHECK (
    (auth.role() = 'authenticated')
    AND (
      (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd'
      OR (current_setting('jwt.claims.email', true) LIKE '%@diu.edu.bd')
    )
  );

CREATE POLICY "Update own posts" ON posts
  FOR UPDATE
  USING (author_id = auth.uid())
  WITH CHECK (author_id = auth.uid());

CREATE POLICY "Delete own posts" ON posts
  FOR DELETE
  USING (author_id = auth.uid());

-- Jobs and education opportunities: allow DIU authenticated users to insert and read
CREATE POLICY "Select jobs" ON jobs
  FOR SELECT
  USING (
    (auth.role() = 'authenticated')
    AND (
      (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd'
      OR (current_setting('jwt.claims.email', true) LIKE '%@diu.edu.bd')
    )
  );

CREATE POLICY "Insert jobs for DIU users" ON jobs
  FOR INSERT
  WITH CHECK (
    (auth.role() = 'authenticated')
  );

CREATE POLICY "Select education opportunities" ON education_opportunities
  FOR SELECT
  USING (
    (auth.role() = 'authenticated')
    AND (
      (auth.jwt() ->> 'email') LIKE '%@diu.edu.bd'
      OR (current_setting('jwt.claims.email', true) LIKE '%@diu.edu.bd')
    )
  );

CREATE POLICY "Insert education opportunities for DIU users" ON education_opportunities
  FOR INSERT
  WITH CHECK (
    (auth.role() = 'authenticated')
  );

-- =====================================================
-- Helpful example queries (client side uses Supabase JS; server-side or SQL console can use these to inspect)
-- =====================================================
-- Insert a profile (example)
-- INSERT INTO profiles (auth_id, email, full_name) VALUES ('00000000-0000-0000-0000-000000000000', 'user@diu.edu.bd', 'User Name');

-- Create a post (example)
-- INSERT INTO posts (author_id, title, body) VALUES ('<profile-uuid>', 'Hello World', 'This is the first post');

-- Add a comment
-- INSERT INTO comments (post_id, author_id, content) VALUES ('<post-uuid>', '<profile-uuid>', 'Nice post!');

-- Add a reply to a comment (set parent_id to the comment being replied to)
-- INSERT INTO comments (post_id, parent_id, author_id, content) VALUES ('<post-uuid>', '<parent-comment-uuid>', '<profile-uuid>', 'Thanks! Replying to your comment.');

-- Add a like (client should use insert into post_likes)
-- INSERT INTO post_likes (post_id, user_id) VALUES ('<post-uuid>', '<profile-uuid>');

-- =====================================================
-- Final notes and troubleshooting
-- =====================================================
-- 1) RLS and JWT claims: If policies using `auth.jwt()` fail, test what claims are available by creating a policy that returns the jwt claim or by temporarily allowing SELECT for authenticated users and then querying `auth.jwt()` in a SQL function.
-- 2) When enabling RLS, make sure to keep at least one working policy for read operations; otherwise your client will get permission errors.
-- 3) Realtime: Supabase Realtime must be allowed for the tables you want to subscribe to. In the Supabase UI, verify Realtime is enabled for `posts`, `comments`, and `post_likes`.
-- 4) OAuth redirect URIs: add exact origins + path where you use `redirectTo` in your client code (e.g., `https://example.com/blog.html`) to Supabase -> Authentication -> Settings -> Redirect URLs.
-- 5) CLI migrations: to use the supabase CLI migrations, create a migration file under your project's `supabase/migrations` folder and paste this SQL. Then run `supabase db push` or follow your chosen workflow.

-- End of file
